---
- name: Provision Apache SSL demo server (baseline + cert status page)
  hosts: all
  become: true
  gather_facts: true

  vars:
    httpd_service: httpd
    bundle_dir_2025: certs/cert_bundle/2025-current

    tls_cert_path: /etc/pki/tls/certs/server.pem
    tls_key_path: /etc/pki/tls/private/server.key

    ssl_docroot: /var/www/html
    certinfo_script_path: /usr/local/bin/generate_certinfo.sh

    # Drop-in vhost config
    ssl_conf_path: /etc/httpd/conf.d/ssl.conf

    # Pick the initial cert/key from the 2025 bundle
    # (we'll auto-set this to the AWS Name tag hostname "webX" if possible)
    initial_cert_basename: web

    # AWS region for tag lookup (used only if running on EC2)
    aws_region: "{{ lookup('env','AWS_REGION') | default('us-east-2') }}"

  handlers:
    - name: restart apache
      ansible.builtin.service:
        name: "{{ httpd_service }}"
        state: restarted
        enabled: true

  tasks:
    # --- Best-effort: set hostname from AWS Name tag AND use it to pick the right initial cert basename ---
    - name: Best-effort: set hostname from AWS Name tag and derive initial cert basename
      block:
        - name: Get EC2 instance-id from metadata
          ansible.builtin.uri:
            url: http://169.254.169.254/latest/meta-data/instance-id
            return_content: true
            timeout: 2
          register: instance_id
          changed_when: false

        - name: Lookup Name tag from AWS
          delegate_to: localhost
          amazon.aws.ec2_instance_info:
            instance_ids:
              - "{{ instance_id.content }}"
            region: "{{ aws_region }}"
          register: ec2_info

        - name: Set aws_name fact if Name tag present
          ansible.builtin.set_fact:
            aws_name: "{{ ec2_info.instances[0].tags.Name }}"
          when:
            - ec2_info.instances | length > 0
            - ec2_info.instances[0].tags is defined
            - ec2_info.instances[0].tags.Name is defined

        - name: Apply hostname if different
          ansible.builtin.hostname:
            name: "{{ aws_name }}"
          when:
            - aws_name is defined
            - ansible_hostname != aws_name

        # Refresh facts so anything later that relies on hostname/fqdn isn't stale
        - name: Refresh facts after hostname change
          ansible.builtin.setup:
          when: aws_name is defined

        # For your bundle naming: web1.demo.local -> "web1"
        - name: Derive initial cert basename from aws_name (webX)
          ansible.builtin.set_fact:
            initial_cert_basename: "{{ (aws_name | lower).split('.')[0] }}"
          when: aws_name is defined

      rescue:
        # Swallow any errors and continue silently
        - ansible.builtin.meta: noop

    # If AWS name couldn't be resolved, fall back to inventory hostname (common in AAP)
    - name: Fallback initial cert basename from inventory hostname
      ansible.builtin.set_fact:
        initial_cert_basename: "{{ (inventory_hostname | lower).split('.')[0] }}"
      when: initial_cert_basename == 'web' and (inventory_hostname is defined)

    # --- Rest of provisioning ---
    - name: Install Apache + SSL packages
      ansible.builtin.package:
        name:
          - httpd
          - mod_ssl
          - openssl
        state: present

    - name: Ensure TLS directories exist
      ansible.builtin.file:
        path: "{{ item }}"
        state: directory
        owner: root
        group: root
        mode: "0755"
      loop:
        - "{{ tls_cert_path | dirname }}"
        - "{{ tls_key_path | dirname }}"

    - name: Install initial (expiring 2025) cert (best-effort, skip if missing)
      ansible.builtin.copy:
        src: "{{ bundle_dir_2025 }}/{{ initial_cert_basename }}_san_cert.pem"
        dest: "{{ tls_cert_path }}"
        owner: root
        group: root
        mode: "0644"
      notify: restart apache
      ignore_errors: true

    - name: Install initial (expiring 2025) key (best-effort, skip if missing)
      ansible.builtin.copy:
        src: "{{ bundle_dir_2025 }}/{{ initial_cert_basename }}_san_key.pem"
        dest: "{{ tls_key_path }}"
        owner: root
        group: root
        mode: "0600"
      notify: restart apache
      ignore_errors: true

    - name: Install SSL vhost config from template
      ansible.builtin.template:
        src: templates/ssl.conf.j2
        dest: "{{ ssl_conf_path }}"
        owner: root
        group: root
        mode: "0644"
      notify: restart apache

    - name: Install generate_certinfo script
      ansible.builtin.copy:
        src: files/generate_certinfo.sh
        dest: "{{ certinfo_script_path }}"
        owner: root
        group: root
        mode: "0755"

    - name: Install TLS status index.html from template
      ansible.builtin.template:
        src: templates/index.html.j2
        dest: "{{ ssl_docroot }}/index.html"
        owner: root
        group: root
        mode: "0644"
      notify: restart apache

    - name: Generate initial certinfo.json (best-effort)
      ansible.builtin.command: "{{ certinfo_script_path }}"
      changed_when: false
      ignore_errors: true

    - name: Ensure Apache is enabled and running
      ansible.builtin.service:
        name: "{{ httpd_service }}"
        state: started
        enabled: true
